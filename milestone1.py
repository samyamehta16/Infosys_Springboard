# -*- coding: utf-8 -*-
"""Milestone1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y_meSn7_l5Q6u9DBjoh_XAICto229AA6

# Milestone 1 â€” Code Explainer

Colab-ready notebook: AST parsing, tokenization, embeddings (MiniLM, DistilRoBERTa, MPNet), comparisons and visualizations.
"""

!pip install -q sentence-transformers scikit-learn matplotlib seaborn transformers nltk
!python -m nltk.downloader punkt

import ast
import os
import math
import json
from typing import List, Dict, Any
import numpy as np
from sentence_transformers import SentenceTransformer
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

snippets = [
"""
import math

def factorial(n):
    if n==0:
        return 1
    return n*factorial(n-1)
""",
"""
from collections import Counter

def most_common(items):
    c = Counter(items)
    return c.most_common(1)[0]
""",
"""
class Stack:
    def __init__(self):
        self.s=[]
    def push(self,x):
        self.s.append(x)
    def pop(self):
        return self.s.pop()
""",
"""
def bubble_sort(arr):
    n=len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j]>arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
""",
"""
import requests

def fetch_json(url):
    r = requests.get(url)
    return r.json()
""",
"""
def fibonacci(n):
    a,b=0,1
    for _ in range(n):
        a,b=b,a+b
    return a
""",
"""
def is_prime(n):
    if n<=1: return False
    if n<=3: return True
    if n%2==0 or n%3==0: return False
    i=5
    while i*i<=n:
        if n%i==0 or n%(i+2)==0:
            return False
        i+=6
    return True
""",
"""
def flatten(nested):
    out=[]
    for sub in nested:
        for elem in sub:
            out.append(elem)
    return out
""",
"""
from functools import lru_cache

@lru_cache(None)
def tribonacci(n):
    if n<3:
        return 1
    return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3)
""",
"""
async def get_data(session, url):
    async with session.get(url) as resp:
        return await resp.json()
"""
]

len(snippets)

def extract_ast_info(code_str: str):
    tree = ast.parse(code_str)
    functions = []
    classes = []
    imports = []
    patterns = {
        'recursion': False,
        'decorators': False,
        'async': False,
        'list_comprehension': False,
    }
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            fn_name = node.name
            doc = ast.get_docstring(node)
            functions.append({'name': fn_name, 'doc': doc})
            for n in ast.walk(node):
                if isinstance(n, ast.Call) and isinstance(n.func, ast.Name) and n.func.id == fn_name:
                    patterns['recursion'] = True
                if isinstance(n, ast.AsyncFunctionDef):
                    patterns['async'] = True
                if isinstance(n, ast.ListComp):
                    patterns['list_comprehension'] = True
                if node.decorator_list:
                    patterns['decorators'] = True
        if isinstance(node, ast.ClassDef):
            classes.append(node.name)
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            if isinstance(node, ast.Import):
                for n in node.names:
                    imports.append(n.name)
            else:
                imports.append(node.module)
        if isinstance(node, ast.AsyncFunctionDef):
            patterns['async'] = True
    return {
        'functions': functions,
        'classes': classes,
        'imports': list(set([i for i in imports if i])),
        'patterns': patterns
    }

summaries = [extract_ast_info(s) for s in snippets]

for i, s in enumerate(summaries):
    print(i, s)

def make_summary_text(code_str, ast_info):
    parts = []
    if ast_info['imports']:
        parts.append('imports: ' + ', '.join(ast_info['imports']))
    if ast_info['classes']:
        parts.append('classes: ' + ', '.join(ast_info['classes']))
    if ast_info['functions']:
        parts.append('functions: ' + ', '.join([f['name'] for f in ast_info['functions']]))
    patt = [k for k,v in ast_info['patterns'].items() if v]
    if patt:
        parts.append('patterns: ' + ', '.join(patt))
    parts.append('code: ' + ' '.join(code_str.strip().split()))
    return ' | '.join(parts)

texts = [make_summary_text(snippets[i], summaries[i]) for i in range(len(snippets))]

for t in texts[:2]:
    print('----')
    print(t[:400])

models = {
    'MiniLM': 'sentence-transformers/all-MiniLM-L6-v2',
    'DistilRoBERTa': 'stsb-distilroberta-base-v2',
    'MPNet': 'sentence-transformers/all-mpnet-base-v2'
}
encoders = {name: SentenceTransformer(path) for name, path in models.items()}

raw_embeddings = {}
summary_embeddings = {}

for name, enc in encoders.items():
    raw_embeddings[name] = enc.encode(snippets, convert_to_numpy=True, show_progress_bar=True)
    summary_embeddings[name] = enc.encode(texts, convert_to_numpy=True, show_progress_bar=True)

def pairwise_cosine_matrix(mat):
    return cosine_similarity(mat)

sim_matrices = {m: pairwise_cosine_matrix(summary_embeddings[m]) for m in summary_embeddings}
mean_pairwise = {
    m: (np.triu(sim_matrices[m], 1).sum() * 2) / (len(snippets)*(len(snippets)-1))
    for m in sim_matrices
}
mean_pairwise

for name, mat in sim_matrices.items():
    plt.figure(figsize=(6,5))
    sns.heatmap(mat, annot=False)
    plt.title(f'Cosine similarity heatmap - {name}')
    plt.show()

for name, emb in summary_embeddings.items():
    pca = PCA(n_components=2)
    Xp = pca.fit_transform(emb)
    plt.figure(figsize=(6,5))
    plt.scatter(Xp[:,0], Xp[:,1])
    for i in range(len(snippets)):
        plt.annotate(str(i), (Xp[i,0], Xp[i,1]))
    plt.title(f'PCA 2D - {name}')
    plt.show()

for name, emb in summary_embeddings.items():
    tsne = TSNE(n_components=2, perplexity=5, random_state=42)
    Xt = tsne.fit_transform(emb)
    plt.figure(figsize=(6,5))
    plt.scatter(Xt[:,0], Xt[:,1])
    for i in range(len(snippets)):
        plt.annotate(str(i), (Xt[i,0], Xt[i,1]))
    plt.title(f't-SNE 2D - {name}')
    plt.show()

names = list(mean_pairwise.keys())
vals = [mean_pairwise[n] for n in names]
plt.figure(figsize=(6,4))
plt.bar(names, vals)
plt.title('Mean pairwise cosine similarity (summary embeddings)')
plt.ylabel('Mean cosine similarity')
plt.show()

out = {
    'snippets': snippets,
    'summaries': texts,
    'summary_embeddings': {k: v.tolist() for k,v in summary_embeddings.items()},
    'raw_embeddings': {k: v.tolist() for k,v in raw_embeddings.items()},
    'sim_matrices': {k: v.tolist() for k,v in sim_matrices.items()},
}
with open('milestone1_results.json','w') as f:
    json.dump(out,f)
print('Saved milestone1_results.json')